#### 优化秒杀任务

##### 概述
创建秒杀任务时，将库存信息存储到redis中,秒杀开始时，使用redis判断用户是否具有秒杀资格（lua脚本），将具有秒杀资格的用户放到阻塞队列中，返回给用户成功，后台开启一个线程一直扫描阻塞队列中的任务，更新数据库


##### lua脚本
- 库存是否充足 判断redis是否大于0
- 用户是否已经秒杀过 使用set集合来判断
- 上面两个条件都符合后，更新redis的缓存，库存减去1，将用户id存放如set集合中

##### 实现的其他问题
- 阻塞队列什么时间进行扫描？
在创建完成类之后就可以开始，因为是阻塞队列，所以不是很消耗cpu性能 可以使用@PostConstruct,在spring创建完类之后会调用

##### 补充
从队列中取出对象，进行数据库库存更新以及创建订单时，可以再次进行判断是否符合要求，做一个兜底处理



#### 达人探店

##### 查看探店笔记  
完成

##### 点赞：
- 点赞功能
Controller的likeBlog()函数，是用户对博文的点赞
redis中保存的是文章中每一个点赞的用户
思路：在redis中进行判断是否点过赞（zscore myzset key   查询zset中是某一元素的得分，可以用来判断zset中是否存在某一个元素）
点赞的进行取消点赞，取消点赞的进行点赞操作（更新数据库库存和redis中的用户列表）

- 查询点赞
在queryBlog()和queryHotBlog()中查询用户是否对博客进行点赞，在返回Blog对象是对isLike进行赋值

##### 排行榜
点赞排行榜： 展示给当前笔记点赞前五名的用户（参考微信，按照点赞时间进行排序）
Zset在存储时就是按照时间戳进行存储的，因此可以轻松返回

由于mybatis返回不是按照id的顺序返回的，因此需要处理，具体实现在likes()函数中，使用order by的时候，传入每一个id，就会按照传入顺序进行排序


#### 关注

##### 共同关注
关注和取关时，在redis中也进行更新，共同关注可以直接求set集合的交集